<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>测试版本3</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f5f5f5;
            height: 100vh;
            width: 100vw;
            font-family: "Microsoft YaHei", "微软雅黑", sans-serif;
            background-image: radial-gradient(circle at 10% 20%, rgba(255,221,225,0.3) 0%, rgba(204,235,255,0.3) 90%);
        }

        .warm-tip-window {
            position: absolute;
            width: 250px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid transparent;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            font-size: 16px;
            font-weight: bold;
            color: #333;
            z-index: 1000;
            user-select: none;
            cursor: move; /* 拖拽光标 */
            animation: popIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            transition: all 0.3s ease;
            backdrop-filter: blur(5px); /* 背景模糊 */
            padding: 0 15px;
            text-align: center;
            word-break: break-all;
        }

        /* 渐变边框 */
        .warm-tip-window::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 12px;
            background: linear-gradient(45deg, var(--border-color1), var(--border-color2));
            z-index: -1;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        /* 鼠标悬停效果增强 */
        .warm-tip-window:hover {
            transform: scale(1.1) rotate(1deg);
            z-index: 1001;
            box-shadow: 0 8px 25px rgba(0,0,0,0.25);
            border-color: rgba(255,255,255,0.8);
        }

        .warm-tip-window:hover::before {
            opacity: 1;
        }

        /* 双击放大效果 */
        .warm-tip-window.active {
            width: 320px;
            height: 80px;
            font-size: 20px;
            transform: scale(1.15) rotate(2deg);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 2000;
            animation: bounce 0.5s ease;
        }

        /* 文字闪烁动画 */
        .text-flicker {
            animation: flicker 3s ease-in-out infinite;
        }

        /* 粒子效果容器 */
        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
        }

        /* 新增动画效果 */
        @keyframes popIn {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            70% { transform: scale(1.1) rotate(5deg); opacity: 0.9; }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }

        @keyframes float {
            0% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(2deg); }
            100% { transform: translateY(0) rotate(0deg); }
        }

        @keyframes pulse {
            0% { box-shadow: 0 4px 15px rgba(0,0,0,0.15); }
            50% { box-shadow: 0 6px 20px rgba(0,0,0,0.25); }
            100% { box-shadow: 0 4px 15px rgba(0,0,0,0.15); }
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            70% { opacity: 1.1; }
        }

        @keyframes bounce {
            0%, 100% { transform: scale(1.15) rotate(2deg); }
            50% { transform: scale(1.2) rotate(-1deg); }
        }

        @keyframes drift {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(10px, -5px) rotate(1deg); }
            50% { transform: translate(0, 10px) rotate(0deg); }
            75% { transform: translate(-10px, -5px) rotate(-1deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }

        /* 文字渐变 */
        .text-gradient {
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            background-image: linear-gradient(45deg, #333, #666);
        }

        /* 底部控制区 */
        .control-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.8);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            color: #666;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 3000;
            backdrop-filter: blur(3px);
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .counter {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn {
            background: linear-gradient(45deg, #8ec5fc, #e0c3fc);
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
        }

        .btn.clear {
            background: linear-gradient(45deg, #ff9aa2, #ffb7b2);
        }

        /* 右键菜单样式 */
        .context-menu {
            position: absolute;
            width: 120px;
            background: rgba(255,255,255,0.95);
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            z-index: 5000;
            display: none;
            backdrop-filter: blur(5px);
        }

        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.2s ease;
            font-size: 14px;
            color: #666;
        }

        .context-menu-item:hover {
            background: rgba(230,230,255,0.7);
        }

        .context-menu-item:first-child {
            border-radius: 8px 8px 0 0;
        }

        .context-menu-item:last-child {
            border-radius: 0 0 8px 8px;
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <div class="counter">咕噜泡泡:<span id="tipCount">0</span> 个</div>
        <button class="btn add" id="addBtn">新增气泡</button>
        <button class="btn clear" id="clearBtn">清空所有</button>
    </div>

    <!-- 右键菜单 -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-action="copy">复制文字</div>
        <div class="context-menu-item" data-action="top">置顶窗口</div>
        <div class="context-menu-item" data-action="random">随机位置</div>
        <div class="context-menu-item" data-action="close">关闭气泡</div>
    </div>

    <script>
        // 核心：动态文字生成系统（模板+替换词库，无限组合）
        const wordLib = {
            prefix: ['悄悄说', '记得', '一定要', '愿你', '希望你', '别忘了', '偷偷告诉你', '其实', '此刻', '忽然觉得'],
            action: ['好好吃饭', '认真休息', '保持快乐', '享受时光', '善待自己', '坚持热爱', '拥抱生活', '放慢脚步', '积攒美好', '传递温暖'],
            emotion: ['甜甜的', '暖暖的', '元气满满的', '温柔的', '坚定的', '轻松的', '治愈的', '安心的', '雀跃的', '从容的'],
            result: ['万事顺意', '好运常在', '笑容常在', '被爱包围', '收获惊喜', '平安喜乐', '心想事成', '日日顺心', '烦恼消散', '幸福感满溢'],
            scene: ['天凉添衣', '天热多喝水', '阴雨天带伞', '熬夜伤身体', '空腹别喝咖啡', '久坐记得拉伸', '累了就歇会儿', '睡前别玩手机'],
            encourage: ['你真的很棒', '再坚持一下', '你比想象中厉害', '不要轻易放弃', '你值得所有美好', '继续闪闪发光', '你的努力会有回报'],
            suffix: ['呀～', '哦～', '呢', '呀', '哦', '呀！', '哦！', '呢～']
        };

        // 文字组合模板
        const textTemplates = [
            '{prefix}，{action}{suffix}',
            '{emotion}{action}，{result}{suffix}',
            '{scene}，{emotion}过一天{suffix}',
            '{encourage}，{action}就好{suffix}',
            '{prefix}，{emotion}你最可爱{suffix}',
            '{action}，{result}呀～',
            '{prefix}，{scene}，别大意{suffix}',
            '{emotion}时光里，{result}{suffix}',
            '{encourage}，未来可期{suffix}',
            '{prefix}，{result}，因为有你{suffix}',
            '{action}，{emotion}幸福感{suffix}',
            '{scene}，{action}更健康{suffix}',
            '{prefix}，你值得{emotion}{result}{suffix}',
            '{encourage}，{emotion}坚持下去{suffix}',
            '{action}，让{emotion}日子常伴{suffix}',
            '{prefix}，{emotion}{action}，好运自来{suffix}'
        ];

        // 颜色库
        const bgColors = [
            'rgba(255, 221, 225, 0.85)', 'rgba(191, 239, 255, 0.85)', 'rgba(204, 255, 204, 0.85)',
            'rgba(230, 230, 255, 0.85)', 'rgba(255, 255, 204, 0.85)', 'rgba(255, 218, 225, 0.85)',
            'rgba(255, 230, 204, 0.85)', 'rgba(221, 255, 255, 0.85)', 'rgba(240, 230, 255, 0.85)',
            'rgba(255, 240, 245, 0.85)', 'rgba(240, 255, 240, 0.85)', 'rgba(255, 250, 240, 0.85)',
            'rgba(225, 242, 255, 0.85)', 'rgba(255, 236, 210, 0.85)', 'rgba(237, 246, 255, 0.85)'
        ];

        // 边框渐变颜色对
        const borderColorPairs = [
            ['#ff9aa2', '#ffb7b2'], ['#8ec5fc', '#e0c3fc'], ['#a8edea', '#fed6e3'],
            ['#ffd1ff', '#fa8bff'], ['#f9f586', '#f8d886'], ['#caffbf', '#9bf6ff'],
            ['#ffadad', '#ffd6a5'], ['#fdffb6', '#caffc7'], ['#9bf6ff', '#bdb2ff']
        ];

        // 粒子颜色库
        const particleColors = [
            'rgba(255, 154, 162, 0.7)', 'rgba(142, 197, 252, 0.7)', 'rgba(168, 237, 234, 0.7)',
            'rgba(255, 209, 255, 0.7)', 'rgba(249, 245, 134, 0.7)', 'rgba(202, 255, 191, 0.7)'
        ];

        let tipCount = 0;
        const tipCountElement = document.getElementById('tipCount');
        const contextMenu = document.getElementById('contextMenu');
        let currentWindow = null;

        // 生成随机文字
        function generateRandomText() {
            const template = textTemplates[Math.floor(Math.random() * textTemplates.length)];
            return template.replace(/{(\w+)}/g, (match, key) => {
                const words = wordLib[key];
                return words[Math.floor(Math.random() * words.length)];
            });
        }

        // 随机获取颜色对
        function getRandomColorPair() {
            const pair = borderColorPairs[Math.floor(Math.random() * borderColorPairs.length)];
            const bgColor = bgColors[Math.floor(Math.random() * bgColors.length)];
            return { bgColor, border1: pair[0], border2: pair[1] };
        }

        // 显示温馨提示窗口
        function showWarmTip() {
            const tipWindow = document.createElement('div');
            tipWindow.className = 'warm-tip-window text-gradient';
            
            // 生成内容和样式
            const text = generateRandomText();
            const { bgColor, border1, border2 } = getRandomColorPair();
            
            tipWindow.innerText = text;
            tipWindow.style.backgroundColor = bgColor;
            tipWindow.style.setProperty('--border-color1', border1);
            tipWindow.style.setProperty('--border-color2', border2);

            // 随机位置（避免边缘）
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const winWidth = 250;
            const winHeight = 60;

            const x = 20 + Math.random() * (screenWidth - winWidth - 40);
            const y = 20 + Math.random() * (screenHeight - winHeight - 40);

            tipWindow.style.left = x + 'px';
            tipWindow.style.top = y + 'px';

            // 随机动画效果
            const animType = Math.random();
            if (animType > 0.6) {
                tipWindow.style.animation = 'float 8s ease-in-out infinite';
            } else if (animType > 0.3) {
                tipWindow.style.animation = 'pulse 4s ease-in-out infinite';
            } else {
                tipWindow.style.animation = 'drift 12s ease-in-out infinite';
            }

            // 20%概率添加文字闪烁效果
            if (Math.random() < 0.2) {
                tipWindow.classList.add('text-flicker');
            }

            // 存储初始位置和速度（用于碰撞检测）
            tipWindow.dataset.speedX = (Math.random() - 0.5) * 0.5; // -0.25 到 0.25
            tipWindow.dataset.speedY = (Math.random() - 0.5) * 0.5;

            // 拖拽功能
            makeDraggable(tipWindow);

            // 左键点击：变色+粒子效果
            tipWindow.onclick = function(e) {
                e.stopPropagation();
                // 切换颜色
                const { bgColor: newBg, border1: newBorder1, border2: newBorder2 } = getRandomColorPair();
                this.style.backgroundColor = newBg;
                this.style.setProperty('--border-color1', newBorder1);
                this.style.setProperty('--border-color2', newBorder2);
                
                // 粒子效果
                createParticles(e.clientX, e.clientY);
            };

            // 双击放大/还原+刷新文字
            tipWindow.ondblclick = function(e) {
                e.stopPropagation();
                this.classList.toggle('active');
                
                if (this.classList.contains('active')) {
                    this.innerText = generateRandomText();
                } else {
                    this.innerText = generateRandomText();
                    // 恢复动画
                    const animType = Math.random();
                    if (animType > 0.6) {
                        this.style.animation = 'float 8s ease-in-out infinite';
                    } else if (animType > 0.3) {
                        this.style.animation = 'pulse 4s ease-in-out infinite';
                    } else {
                        this.style.animation = 'drift 12s ease-in-out infinite';
                    }
                }
            };

            // 右键菜单
            tipWindow.oncontextmenu = function(e) {
                e.preventDefault();
                currentWindow = this;
                
                // 显示菜单
                contextMenu.style.display = 'block';
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
            };

            // 自动躲避重叠
            avoidOverlap(tipWindow);

            document.body.appendChild(tipWindow);
            tipCount++;
            updateTipCount();

            // 启动自动移动和碰撞检测
            startAutoMove(tipWindow);
        }

        // 拖拽功能
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

            element.onmousedown = dragStart;

            function dragStart(e) {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;

                element.style.zIndex = 2000;
                document.onmousemove = dragMove;
                document.onmouseup = dragEnd;
            }

            function dragMove(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;

                const newLeft = element.offsetLeft - pos1;
                const newTop = element.offsetTop - pos2;
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const winWidth = element.offsetWidth;
                const winHeight = element.offsetHeight;

                // 边界检测
                if (newLeft >= 0 && newLeft <= screenWidth - winWidth) {
                    element.style.left = newLeft + "px";
                }
                if (newTop >= 0 && newTop <= screenHeight - winHeight) {
                    element.style.top = newTop + "px";
                }
            }

            function dragEnd() {
                element.style.zIndex = 1000;
                document.onmousemove = null;
                document.onmouseup = null;
            }
        }

        // 自动移动和碰撞检测
        function startAutoMove(element) {
            function move() {
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const winWidth = element.offsetWidth;
                const winHeight = element.offsetHeight;

                let x = parseInt(element.style.left) || 0;
                let y = parseInt(element.style.top) || 0;
                let speedX = parseFloat(element.dataset.speedX);
                let speedY = parseFloat(element.dataset.speedY);

                // 边界碰撞检测
                if (x <= 0 || x >= screenWidth - winWidth) {
                    speedX = -speedX; // 反向
                    element.dataset.speedX = speedX;
                }
                if (y <= 0 || y >= screenHeight - winHeight) {
                    speedY = -speedY; // 反向
                    element.dataset.speedY = speedY;
                }

                // 更新位置
                x += speedX;
                y += speedY;

                element.style.left = x + 'px';
                element.style.top = y + 'px';

                // 继续动画
                if (element.parentNode) {
                    requestAnimationFrame(move);
                }
            }

            move();
        }

        // 避免重叠
        function avoidOverlap(newWindow) {
            const allWindows = document.querySelectorAll('.warm-tip-window');
            if (allWindows.length <= 1) return;

            const newRect = newWindow.getBoundingClientRect();
            let overlap = false;

            allWindows.forEach(window => {
                if (window === newWindow) return;
                const rect = window.getBoundingClientRect();
                if (
                    newRect.left < rect.right &&
                    newRect.right > rect.left &&
                    newRect.top < rect.bottom &&
                    newRect.bottom > rect.top
                ) {
                    overlap = true;
                }
            });

            if (overlap) {
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const winWidth = newWindow.offsetWidth;
                const winHeight = newWindow.offsetHeight;

                const newLeft = 20 + Math.random() * (screenWidth - winWidth - 40);
                const newTop = 20 + Math.random() * (screenHeight - winHeight - 40);

                newWindow.style.left = newLeft + 'px';
                newWindow.style.top = newTop + 'px';
            }
        }

        // 粒子效果
        function createParticles(x, y) {
            const particleCount = 15;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';

                const size = 3 + Math.random() * 8;
                const color = particleColors[Math.floor(Math.random() * particleColors.length)];
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 5;
                const distance = 5 + Math.random() * 20;

                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.backgroundColor = color;
                particle.style.left = x - size/2 + 'px';
                particle.style.top = y - size/2 + 'px';

                let startTime = Date.now();
                const duration = 800 + Math.random() * 500;

                function updateParticle() {
                    const elapsed = Date.now() - startTime;
                    if (elapsed > duration) {
                        particle.remove();
                        return;
                    }

                    const progress = elapsed / duration;
                    const currentDistance = distance * progress;
                    const newX = x - size/2 + Math.cos(angle) * currentDistance;
                    const newY = y - size/2 + Math.sin(angle) * currentDistance;

                    particle.style.left = newX + 'px';
                    particle.style.top = newY + 'px';
                    particle.style.opacity = 1 - progress;

                    requestAnimationFrame(updateParticle);
                }

                document.body.appendChild(particle);
                requestAnimationFrame(updateParticle);
            }
        }

        // 更新计数
        function updateTipCount() {
            tipCountElement.innerText = tipCount;
        }

        // 右键菜单事件
        contextMenu.addEventListener('click', function(e) {
            const action = e.target.dataset.action;
            if (!currentWindow) return;

            switch(action) {
                case 'copy':
                    // 复制文字
                    navigator.clipboard.writeText(currentWindow.innerText)
                        .then(() => {
                            // 复制成功提示
                            const originalText = currentWindow.innerText;
                            currentWindow.innerText = '复制成功！';
                            setTimeout(() => {
                                currentWindow.innerText = originalText;
                            }, 1000);
                        });
                    break;
                case 'top':
                    // 置顶
                    currentWindow.style.zIndex = 3000;
                    break;
                case 'random':
                    // 随机位置
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;
                    const winWidth = currentWindow.offsetWidth;
                    const winHeight = currentWindow.offsetHeight;

                    const x = 20 + Math.random() * (screenWidth - winWidth - 40);
                    const y = 20 + Math.random() * (screenHeight - winHeight - 40);

                    currentWindow.style.left = x + 'px';
                    currentWindow.style.top = y + 'px';
                    break;
                case 'close':
                    // 关闭
                    createParticles(
                        parseInt(currentWindow.style.left) + currentWindow.offsetWidth/2,
                        parseInt(currentWindow.style.top) + currentWindow.offsetHeight/2
                    );
                    currentWindow.style.opacity = "0";
                    currentWindow.style.transform = "scale(0.8)";
                    setTimeout(() => {
                        if (currentWindow.parentNode) {
                            currentWindow.parentNode.removeChild(currentWindow);
                            tipCount--;
                            updateTipCount();
                        }
                    }, 300);
                    break;
            }

            // 隐藏菜单
            contextMenu.style.display = 'none';
            currentWindow = null;
        });

        // 点击空白处关闭右键菜单
        document.addEventListener('click', function() {
            contextMenu.style.display = 'none';
            currentWindow = null;
        });

        // 点击空白处添加新窗口
        document.body.onclick = function(e) {
            if (e.target === document.body) {
                showWarmTip();
            }
        };

        // 按钮事件
        document.getElementById('addBtn').addEventListener('click', function(e) {
            e.stopPropagation();
            showWarmTip();
        });

        document.getElementById('clearBtn').addEventListener('click', function(e) {
            e.stopPropagation();
            const allWindows = document.querySelectorAll('.warm-tip-window');
            allWindows.forEach(window => {
                // 批量粒子效果
                createParticles(
                    parseInt(window.style.left) + window.offsetWidth/2,
                    parseInt(window.style.top) + window.offsetHeight/2
                );
                window.style.opacity = "0";
                window.style.transform = "scale(0.8)";
                setTimeout(() => {
                    if (window.parentNode) {
                        window.parentNode.removeChild(window);
                    }
                }, 300);
            });
            tipCount = 0;
            updateTipCount();
        });

        // 初始化：创建30个窗口
        const totalWindows = 30;
        const intervalDelay = 150;

        for (let i = 0; i < totalWindows; i++) {
            setTimeout(() => {
                showWarmTip();
            }, i * intervalDelay);
        }

        // 窗口大小改变时调整位置
        window.onresize = function() {
            const allWindows = document.querySelectorAll('.warm-tip-window');
            allWindows.forEach(window => {
                const rect = window.getBoundingClientRect();
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const winWidth = window.offsetWidth;
                const winHeight = window.offsetHeight;

                let newLeft = rect.left;
                let newTop = rect.top;

                if (newLeft < 0) newLeft = 20;
                if (newLeft > screenWidth - winWidth) newLeft = screenWidth - winWidth - 20;
                if (newTop < 0) newTop = 20;
                if (newTop > screenHeight - winHeight) newTop = screenHeight - winHeight - 20;

                window.style.left = newLeft + 'px';
                window.style.top = newTop + 'px';
            });
        };
    </script>
</body>
</html>